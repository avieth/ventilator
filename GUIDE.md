# Software Instructions

This section contains an overview of the software design, as well as
instructions to build and install it.

## Quickstart

Find in `./arduinobits/` an Arduino IDE sketch for the Arduino Mega board.
Perhaps the easiest way to build a binary and flash it to a board is to use
the Aurdino IDE itself. Open this sketch in the IDE, connect the board, then
build and upload the sketch (Ctrl+U).

## System Description

The software system is factored into two components:

- Low-level interfacing with sensors, switches, motor controls, human-input
  devices, etc.
- High-level definition of the ventilation system itself.

The former is written in C, targeting the Arduino Mega, but in principle is
appropriate for any board with similar or better capabilities in terms of I/O
pins and microprocessor.

The second is expressed in [Haskell](https://www.haskell.org/), by way of the
[copilot](https://copilot-language.github.io/) suite of tools (BSD3 licensed).
copilot was developed by Galois Inc. in partnership with NASA, to be applied in
the runtime verification of unmanned aerial vehicle software[1]. A copilot
specification is expressed in terms of pure functional streams of data--without
destructive updates, pointers, or implicit type casts--and complies to C99
suitable for execution in low-memory, real-time environments, without loops or
dynamic memory allocation.

In a software system where failure can lead to physical harm, high assurance is
of utmost importance. The decision to use a domain-specific specification
language, rather than a direct implementation in C, means it is easier to
characterize, understand, and mitigate failure modes. As an added benefit, bug
fixing, feature iteration, and general experimentation is much faster this way,
due to the modularity and safety intrinsic to a pure functional language with
a modern type system.

The `./spec` directory contains the Haskell source files expressing the
ventilator program abstract over hardware. The `./arduinobits/` directory
contains the C source files expressing the interface between hardware and
spec. The files `./arduinobits/ventilator.c` and `./arduinobits/ventilator.h`
are generated by the Haskell spec.

[1](https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20120001989.pdf)

## Detailed Build Instructions

### Haskell Bits

In order to generate the `ventilator.c` and `ventilator.h` source files,
to be included in the Arduino sketch, we must build and run the Haskell
project found in `./spec/`.

#### Fully Automatic

With [nix](https://nixos.org/nix/) installed, a reproducible build is trivial:

```sh
$ ./generate.sh
```

This will `nix-build` the derivation in `./spec/default.nix`, run the resulting
executable, and copy the resulting C files to `./arduinobits/`.

#### Semi Automatic

With the [Haskell Platform](https://www.haskell.org/platform/) installed, the
build is as follows:

```sh
$ cd ./spec
$ cabal new-run exe:generate-c
```

This will build the executable using cabal, the Haskell build tool, and leave
the generated files in the `./spec` directory.

### Arduino Bits

With the generated `ventilator.c` and `ventilator.h` files in hand, the
complete executable can be built by any suitable Arduino build tool. Most
users would probably use the Arduino IDE, but there is also the
[Arduino Makefile](https://github.com/sudar/Arduino-Makefile) project.

Required Arduino libraries are the standard
[LCD library](https://github.com/arduino-libraries/LiquidCrystal) and
[Paul Stoffregen's Encoder library](https://github.com/PaulStoffregen/Encoder),
both of which are permissively licensed.

## Hazards and Limitations

### Positive Characterization of Safe Operation

Rather than attempting to imagine every possible failure mode of the controller
software, it would be more prudent to characterize exactly what is the
condition of non-failure, i.e. what must the controller observe in order to
judge that it is safe to move air to or from the patient. Whenever this
condition is not met, the controller must raise visual and audible alarms and
must not move any air until an operator (a medical professional) has diagnosed
and resolved the problem.

### Fractional Arithmetic and Use of Floating Point

Some software subsystems, notably kinematics and volume computation, pressure
sensing, and flow sensing, are implemented using standard IEE754 floating point
arithmetic. This is a safety hazard because errors may accumulate, leading to
the controller delivering too little or too much air to the patient. It is
essential that all such computations are meticulously audited to ensure that
they fall within safe error bounds. Even if they were to be replaced with
fixed point arithmetic, such an audit is required.

Unsafe casts from floating points to integers are present in the software and
are at the moment not checked for unacceptable loss of accuracy.

## API Description

See the [generated docs](./spec/docs/index.html).
