/**
 * This is a very simple demo of how the copilot Haskell EDSL can be used to
 * build a C program suitable for an embedded device, in the context of this
 * mechanical ventilator project.
 *
 * This program demonstrates the basic functionality by simulating "sensor data"
 * according to a very simple model, stepping the system, and displaying plots
 * of volume, flow, and pressure using a crude horrible ncurses interface.
 *
 * In a real embedded application, the loop would look much the same, except
 * that the input would actually be sampled from sensors and the callbacks for
 * set_flow and alarm would actually do what you expect.
 *
 * Follow through comments inline.
 */

#include <unistd.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ncurses.h>

/**
 * This is the header file generated by copilot.
 */
#include "ventilator.h"

/**
 * For simulation, we advance by 1ms per step.
 */
#define TIME_DELTA_MS 1

/**
 * The following block of declarations are each declared extern in ventilator.h,
 * determined by the Haskell copilot program.
 *
 * Here we give initial values for each of them, and we update them according
 * to simulation in set_flow (update_model).
 *
 * Of course, in a real deployment they would be updated by the input routine
 * whenever sensors are sampled.
 */

// 12 breaths per minute
uint8_t user_bpm = 12;
// 1:2 I:E ratio
uint16_t user_ie_ratio = 0x0102;
// Constant time delta between steps of 1ms.
uint32_t time_delta_ms = TIME_DELTA_MS;
// Flow sensor
int32_t flow = 0;
int32_t flow_check = 0;
// Pressure sensor
int32_t pressure = 0;
int32_t pressure_check = 0;
// Oxygen concentration sensor
uint32_t o2_concentration = 0;
uint32_t o2_concentration_check = 0;
// CMV mode is volume controlled
bool cmv_mode = true;
// Volume in the lungs. Here we simulate it by integrating flow
int32_t volume = 0;
// Operator-controlled volume limit. 500mL
int32_t user_volume_limit = 500000;
// Operator-controlled pressure goal for PC CMV. 30cm H2O, or approx 3000 Pa
int32_t user_cmv_pressure_goal = 3000;

/**
 * Lung compliance, for a simulated model of pressure.
 *
 * This is the change in volume over the change in pressure.
 * Unit is microlitres over pascals.
 *
 * TODO find a sensible way of simulating this. 250 seems to be reasonable
 * for now.
 * Apparently constant compliance is observed in real lungs and 200 mL/cmH2O is
 * said to be a typical pulminary compliance for a healthy adult...
 */
int32_t compliance = 250;

/**
 * Updates the simulation model according to the flow value at an instant.
 *
 * In practice, we'll take the data from sensors. But for simulation we assume
 * the desired flow (computed by the copilot program) is identical to the
 * observed flow, and we integrate to get the volume.
 *
 * Pressure is computed according to the compliance.
 *
 * O2 concentration is never changed.
 */
void update_model(int32_t in_flow) {

  // Take flow from the "sensor" value; no independent redundant sensor.
  flow = in_flow;
  flow_check = flow;

  // Integrate flow to get volume. NB: flow is microlitres per millisecond and
  // we have a time delta in milliseconds.
  volume += in_flow * (int32_t) time_delta_ms;

  // Simple constant compliance model for pressure.
  // Since, for compliant lungs, the pressure change will be a fraction of the
  // volume change, and since we don't want to use any floating point
  // arithmetic, we'll compute the whole part and fractional part separately.
  int32_t d_pressure = (1000 * in_flow * (int32_t) time_delta_ms) / compliance;
  int32_t d_pressure_fract = d_pressure % 1000;
  int32_t d_pressure_whole = d_pressure / 1000;
  static int32_t d_pressure_fract_accum = 0;
  d_pressure_fract_accum += d_pressure_fract;
  pressure += d_pressure_whole;
  pressure += d_pressure_fract_accum / 1000;
  d_pressure_fract_accum %= 1000;
  // No redundant sensor for pressure in the model.
  pressure_check = pressure;
}

/**
 * Also declared in ventilator.h, this routine shall be called with the desired
 * flow whenever it needs to be set. That decision is defined in a rather
 * high-level way in the Haskell copilot program.
 */
void set_flow(int32_t in_flow) {
  update_model(in_flow);
}

void raise_alarm(void) {
  // TODO set an alarm global and check it as part of the UI.
  // For now, kill the ncurses app, print a message and exit.
  endwin();
  printf("Alarm raised. Bye.");
  exit(1);
}

#define PLOT_TIME_STEP 200

/**
 * We'll display the total elapsed time.
 */
uint32_t time_ms = 0;

/**
 * This is just a big messy rounte to display plots using ncurses.
 *
 * Prints 3 plots stacked vertically: volume, flow, pressure.
 *
 * Since a terminal is relatively low-res and in fact not at all suitable
 * for plotting, we'll only plot a point once every 200ms. Plotting at a faster
 * rate means the curve appears flatter and that an entire breath cycle
 * probably won't be visible. With 80 columns, plotting once every 10ms gives
 * only 800ms, but every 200ms gives 16 seconds which is probably enough to see
 * an entire breath cycle.
 */
void display(void) {

  int height, width;
  getmaxyx(stdscr, height, width);

  // We need at least 10 rows per-plot, plus 3 rows for the plot headings, 1
  // row for the main heading, and 2 rows for the footer (not implemented).
  if (height < 36) {
    mvprintw(0, 0, "Window too small");
    refresh();
    return;
  };

  mvprintw(0, 0, "BPM: %i, I:E %i:%i, time: %i ms", user_bpm, user_ie_ratio >> 8, user_ie_ratio & 0x00FF, time_ms);

  int plot_height = (height - 6) / 3;

  // Print headings for each plot.
  // We choose units that are apparently common on real ventilators:
  //   Volume in mL
  //   Flow in L/min
  //   Pressure in cm H2O
  int volume_header_row = 1;
  int flow_header_row = volume_header_row + plot_height + 2;
  int pressure_header_row = flow_header_row + plot_height + 2;
  move(volume_header_row, 0);
  clrtoeol();
  // Volume is in uL so getting mL with 4 decimal points is simple.
  mvprintw(volume_header_row, 0, "Volume: %d.%03d mL", volume / 1000, volume % 1000);
  move(flow_header_row, 0);
  clrtoeol();
  // Flow is in uL/ms, or equivalently mL/s.
  int32_t flow_ml_min = flow * 60;
  mvprintw(flow_header_row, 0, "Flow: %d.%03d L/min", flow_ml_min / 1000, flow_ml_min % 1000);
  move(pressure_header_row, 0);
  clrtoeol();
  // Pressure is in Pa, and there are approx. 98 per cm H2O. We'll first multiply
  // by 1000 so we can get the decimal places.
  mvprintw(pressure_header_row, 0, "Pressure: %d.%03d cm H2O", (pressure * 1000) / 98000, ((pressure * 1000) / 98) % 1000);

  // For each plot we have a top row. The plot's row space is this up to
  // this plus plot_height.
  int volume_plot_y = volume_header_row + 1;
  int flow_plot_y = flow_header_row + 1;
  int pressure_plot_y = pressure_header_row + 1;

  // The column for the current frame is special.
  // The value at `sample` goes at this column.
  int now_column = (time_ms / PLOT_TIME_STEP) % width;
  int row = 0;

  int volume_step = 1000000 / plot_height;
  for (int i = 0; i < plot_height; ++i) {
    row = volume_plot_y + plot_height - i;
    if (volume >= (i * volume_step) && volume < ((i + 1) * volume_step)) {
      mvprintw(row, now_column, "+");
    } else {
      mvprintw(row, now_column, " ");
    }
    mvprintw(row, now_column + 1, "|");
  }

  int flow_step = 1024 / plot_height;
  int min_flow = -512;
  for (int i = 0; i < plot_height; ++i) {
    row = flow_plot_y + plot_height - i;
    if (flow >= (i * flow_step + min_flow) && flow < ((i + 1) * flow_step + min_flow)) {
      mvprintw(row, now_column, "+");
    } else {
      mvprintw(row, now_column, " ");
    }
    mvprintw(row, now_column + 1, "| ");
  }

  int pressure_step = 4000 / plot_height;
  int min_pressure = 0;
  for (int i = 0; i < plot_height; ++i) {
    row = pressure_plot_y + plot_height - i;
    if (pressure >= (i * pressure_step + min_pressure) && pressure < ((i + 1) * pressure_step + min_pressure)) {
      mvprintw(row, now_column, "+");
    } else {
      mvprintw(row, now_column, " ");
    }
    mvprintw(row, now_column + 1, "|");
  }

  refresh();

}

void main() {

  // Set up ncurses
  initscr();
  // Raw character input ...
  raw();
  // ... and respect CTRL+C
  cbreak();
  // No terminal cursor
  curs_set(0);

  // Main loop: run the simulation and display the current state.
  while (1) {
    //sample_inputs();
    step();
    display();
    time_ms += time_delta_ms;
    if (usleep(time_delta_ms * 1000) != 0) { break; }
  }

  // Tear down ncurses and exit.
  endwin();
  exit(0);
}
